#ifndef __THREAD_H__
#define __THREAD_H__
#include <ucontext.h>
#include <stdlib.h>
#include <stdio.h>
#include"fifo.h"
#include <valgrind/valgrind.h>
/* identifiant de thread
 * NB: pourra être un entier au lieu d'un pointeur si ca vous arrange,
 *     mais attention aux inconvénient des tableaux de threads
 *     (consommation mémoire, cout d'allocation, ...).
 */

#define STACK_SIZE 64*1024

//define thread errocde
#define Error_ThreadSuccess		0
#define Error_ThreadInit		1
#define Error_ThreadCreate		2	
#define Error_ThreadSuspend 		3
#define Error_ThreadResume	 	4	
#define Error_ThreadTerminated		5
#define Error_ThreadExit		6	
#define Error_ThreadSetPriority		7
#define Error_ThreadWakeup		8
#define Error_ThreadYield		9
#define Error_ThreadDetach		10
#define Error_ThreadJoin		11


/** 
 * different possible thread status
 */

typedef enum
  {READY, //executing now
   RUNNING, //waiting for CPU
   BLOCKED //waiting for I/O or lock
}thread_status;

/** 
 * main thread structure
 */
struct thread_t{
  pid_t id; //identifiant qui s'incrémente
  ucontext_t *uc;
  int valgrind_stackid;
  thread_status status;
  void *retval;
  struct thread_t* next;
  struct thread_t* prev;
  unsigned char priority;
  
};

/*initialise la bibliotheque
 */
extern void lib_init(void);

/* initialise la thread 
*/
extern struct thread_t * thread_init(void);

/* librer la thread
 */

extern void thread_free(struct thread_t *);

/* recuperer l'identifiant du thread courant.
 */
extern struct thread_t thread_self(void);

/* creer un nouveau thread qui va exécuter la fonction func avec l'argument funcarg.
 * renvoie 0 en cas de succès, -1 en cas d'erreur.
 */
extern int thread_create(struct thread_t *newthread, void *(*func)(void *), void *funcarg);

/* passer la main à un autre thread.
 */
extern int thread_yield(void);

/* attendre la fin d'exécution d'un thread.
 * la valeur renvoyée par le thread est placée dans *retval.
 * si retval est NULL, la valeur de retour est ignorée.
 */
extern int thread_join(struct thread_t thread, void **retval);

/* terminer le thread courant en renvoyant la valeur de retour retval.
 * cette fonction ne retourne jamais.
 *
 * L'attribut noreturn aide le compilateur à optimiser le code de
 * l'application (élimination de code mort). Attention à ne pas mettre
 * cet attribut dans votre interface tant que votre thread_exit()
 * n'est pas correctement implémenté (il ne doit jamais retourner).
 */
extern void thread_exit(void *retval) __attribute__ ((__noreturn__));

#endif /* __THREAD_H__ */
