#include "thread.h"
/**
 * global variables :
 * list of waiting threads
 * pointer on current thread
 * pid generator
 */




struct fifo * waitq = NULL;
struct thread_t *current = NULL;
unsigned int ID = 0;
struct itimerval *timer;
struct sigaction *sa;

void preemption(int i){
  thread_yield();
}


void lib_init(void){
  //handler
  
  sa = (struct sigaction *)malloc(sizeof(struct sigaction));
  sa->sa_handler = preemption;
  sigemptyset(&sa->sa_mask);
  sa->sa_flags=0;
  sigaction(SIGALRM, sa, NULL);//SIGVTALRM
  timer = (struct itimerval *)malloc(sizeof(struct itimerval));
  waitq = fifo_create();
  current = (struct thread_t *)malloc(sizeof(struct thread_t));
  thread_init(current);
}


void thread_init(struct thread_t *thread){
  
  thread->id = ID++;
  thread->status = READY;
  thread->retval = NULL;
  thread->join_thread = NULL;

  //thread->priorite == NULL;
  thread->priorite = 20;
  //  thread->f_sig = NULL;
  thread->uc = (ucontext_t *) malloc(sizeof(ucontext_t));
  getcontext(thread->uc);
  thread->uc->uc_stack.ss_size = STACK_SIZE;
  thread->uc->uc_stack.ss_sp = malloc(thread->uc->uc_stack.ss_size);
  if(thread->uc->uc_stack.ss_sp == NULL){
    perror("Malloc : Couldn't allocate The stack\n");
    exit(1);
  }
  thread->uc->uc_stack.ss_flags = 0;
  thread->uc->uc_link = NULL;
  thread->valgrind_stackid = VALGRIND_STACK_REGISTER(thread->uc->uc_stack.ss_sp, thread->uc->uc_stack.ss_sp +thread->uc->uc_stack.ss_size);  
  
}
/* liberer un thread
 */
void thread_free(struct thread_t *thread){

  if(thread != NULL){

    if(thread->uc->uc_stack.ss_sp != NULL)
      free(thread->uc->uc_stack.ss_sp);
    VALGRIND_STACK_DEREGISTER(thread->valgrind_stackid);
    free(thread->uc);
  }
}

struct thread_t *thread_self(void){
  if(waitq == NULL)
    lib_init();
  return current;
}



void thread_init_prio(struct thread_t *thread,int prio){
  
  thread->id = ID++;
  thread->status = READY;
  thread->retval = NULL;
  thread->join_thread = NULL;

  //thread->priorite == NULL;
  thread->priorite = prio;
  //  thread->f_sig = NULL;
  thread->uc = (ucontext_t *) malloc(sizeof(ucontext_t));
  getcontext(thread->uc);
  thread->uc->uc_stack.ss_size = STACK_SIZE;
  thread->uc->uc_stack.ss_sp = malloc(thread->uc->uc_stack.ss_size);
  if(thread->uc->uc_stack.ss_sp == NULL){
    perror("Malloc : Couldn't allocate The stack\n");
    exit(1);
  }
  thread->uc->uc_stack.ss_flags = 0;
  thread->uc->uc_link = NULL;
  thread->valgrind_stackid = VALGRIND_STACK_REGISTER(thread->uc->uc_stack.ss_sp, thread->uc->uc_stack.ss_sp +thread->uc->uc_stack.ss_size);  
  
}

int thread_create(struct thread_t *newthread, void *(*func)(void *), void *funcarg)
{ 
  if (waitq == NULL)
    lib_init();



  struct thread_t *old = current;
  thread_init(newthread);
  makecontext(newthread->uc, (void (*)(void)) exec, 2, func, funcarg);
  fifo_addthreadprio(waitq, old);
  current = newthread; 
  
  swapcontext(old->uc, newthread->uc);
  return 0;
}

int thread_create_prio(struct thread_t *newthread, void *(*func)(void *), void *funcarg,int prio)
{ 
  if (waitq == NULL)
    lib_init();


  struct thread_t *old = current;
  thread_init_prio(newthread,prio);
  //newthread->priorite = prio;
  makecontext(newthread->uc, (void (*)(void)) exec, 2, func, funcarg);
  fifo_addthreadprio(waitq, old);
  current = newthread; 
  
  swapcontext(old->uc, newthread->uc);
  return 0;
}



/* attendre la fin d'exécution d'un thread.
 * la valeur renvoyée par le thread est placée dans *retval.
 * si retval est NULL, la valeur de retour est ignorée.
 */
int thread_yield() {
  
  if(waitq == NULL)
    lib_init();
  
  timer->it_interval.tv_sec = 0;
  timer->it_value.tv_usec = 0;
  timer->it_value.tv_sec = 1;
  //initialise le timer
  //printf("ici////");
  if (setitimer (ITIMER_REAL, timer, NULL)){
    printf("timer error//\n");
  }  
  
  if(fifo_isempty(waitq)){
    if(current->status == TERMINATED)
      exit(current->retval);
    else
      swapcontext(current->uc, current->uc);
  }
    
  else{
    struct thread_t* old = current;
    struct thread_t* new = fifo_remove_head(waitq); 
    new->status = RUNNING;
    current = new;
  
    if(old->status == TERMINATED)
      setcontext(new->uc);
    else{
  
      fifo_addthreadprio(waitq,old);
      old->status = READY;
      swapcontext(old->uc,new->uc); 
    }
  }

  
  
  return 0;
}

int thread_join(struct thread_t *thread, void **retval){
  
  thread->join_thread = thread_self();
  struct thread_t* new = NULL;
  struct thread_t* old = NULL;
  while(thread->status != TERMINATED){
    new = fifo_remove_head(waitq); 
    old = current;
    new->status = RUNNING;
    current = new;
    old->status = READY;
    swapcontext(old->uc,new->uc); 
  }
    
  *retval = thread->retval;
  thread_free(thread);
   return 0; 
 }

void exec(void* func(void*) , void* funcarg){
  //init du timer
  
  timer->it_interval.tv_sec = 0;
  timer->it_value.tv_usec = 0;
  timer->it_value.tv_sec = 1;
  //printf("ici////");
  if (setitimer (ITIMER_REAL, timer, NULL)){
    printf("timer error//\n");
  }  
  
  thread_exit(func(funcarg));
}


/* terminer le thread courant en renvoyant la valeur de retour retval.
 * cette fonction ne retourne jamais.
 *
 * L'attribut noreturn aide le compilateur à optimiser le code de
 * l'application (élimination de code mort). Attention à ne pas mettre
 * cet attribut dans votre interface tant que votre thread_exit()
 * n'est pas correctement implémenté (il ne doit jamais retourner).
 */
void thread_exit(void* retval) {
  struct thread_t* t = current;
  t->retval = retval;
  t->status = TERMINATED; 
  if(t->join_thread != NULL)
    fifo_addhead(waitq, t->join_thread);
  
  thread_yield();
  
}

/* void pthread_setschedparam(struct thread_t * thread, int priority , const struct sched_param * param){ */

/* } */

void thread_setschedprio(struct thread_t * thread, int priority){
  thread->priorite = priority;
}



