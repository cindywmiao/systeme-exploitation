#include "thread.h"
/**
 * global variables :
 * list of running threads
 * list of waiting threads
 * pointer on current thread
 * pid generator
 */




struct fifo * waitq = NULL;
struct thread_t *current = NULL;
unsigned int ID = 0;

void lib_init(void){
  waitq = fifo_create();
  current = (struct thread_t *)malloc(sizeof(struct thread_t));
  thread_init(current);
}


void thread_init(struct thread_t *thread){
  
  thread->id = ID++;
  thread->status = READY;
  thread->retval = NULL;
  thread->uc = (ucontext_t *) malloc(sizeof(ucontext_t));
  getcontext(thread->uc);
  thread->uc->uc_stack.ss_size = STACK_SIZE;
  thread->uc->uc_stack.ss_sp = malloc(thread->uc->uc_stack.ss_size);
  if(thread->uc->uc_stack.ss_sp == NULL){
    perror("Malloc : Couldn't allocate The stack\n");
    exit(1);
  }
  thread->uc->uc_stack.ss_flags = 0;
  thread->uc->uc_link = NULL;
  thread->valgrind_stackid = VALGRIND_STACK_REGISTER(thread->uc->uc_stack.ss_sp, thread->uc->uc_stack.ss_sp +thread->uc->uc_stack.ss_size);  
  
}
/* liberer un thread
 */
void thread_free(struct thread_t *thread){

  if(thread != NULL){

    if(thread->uc->uc_stack.ss_sp != NULL)
      free(thread->uc->uc_stack.ss_sp);
    VALGRIND_STACK_DEREGISTER(thread->valgrind_stackid);
    free(thread->uc);
  }
}

struct thread_t *thread_self(void){
  if(waitq == NULL)
    lib_init();
  return current;
}


int thread_create(struct thread_t *newthread, void *(*func)(void *), void *funcarg)
{ 
  if (waitq == NULL)
    lib_init();

  struct thread_t *old = current;
  thread_init(newthread);
  makecontext(newthread->uc, (void (*)(void)) exec, 2, func, funcarg);
  fifo_addthread(waitq, old);
  current = newthread; 
  
  swapcontext(old->uc, newthread->uc);
  return 0;
}


/* attendre la fin d'exécution d'un thread.
 * la valeur renvoyée par le thread est placée dans *retval.
 * si retval est NULL, la valeur de retour est ignorée.
 */
int thread_yield() {
  
  if(waitq == NULL)
    lib_init();
  
  
  if(fifo_isempty(waitq))
    swapcontext(current->uc, current->uc);
  else{
    struct thread_t* old = current;
    struct thread_t* new = fifo_remove_head(waitq); 
    new->status = RUNNING;
    current = new;
  
    if(old->status == TERMINATED)
      setcontext(new->uc);
    else{
  
      fifo_addthread(waitq,old);
      old->status = READY;
      swapcontext(old->uc,new->uc); 
    }
  }
  return 0;
}

int thread_join(struct thread_t *thread, void **retval){
  
  while(thread->status != TERMINATED){
    
    thread_yield();
  }
  
  *retval = thread->retval;
  thread_free(thread);
  return 0; 
}

void exec(void* func(void*) , void* funcarg){
  thread_exit(func(funcarg));
}


/* terminer le thread courant en renvoyant la valeur de retour retval.
 * cette fonction ne retourne jamais.
 *
 * L'attribut noreturn aide le compilateur à optimiser le code de
 * l'application (élimination de code mort). Attention à ne pas mettre
 * cet attribut dans votre interface tant que votre thread_exit()
 * n'est pas correctement implémenté (il ne doit jamais retourner).
 */
void thread_exit(void* retval) {
  struct thread_t* t = current;
  t->retval = retval;
  t->status = TERMINATED; 
  thread_yield();
}
