Dans cette partie, nous allons présenter et expliquer les modifications que nous avons apportées à nos structures de thread et de fifo au fur et à mesure de la mise en place de nouvelles fonctionnalités avancées. 


\subsection{La structure des threads}

Pour représenter un thread en mémoire, nous avons défini la structure suivante :

\begin{verbatim}
struct thread_t {

       pid_t pid;
       ucontext_t uc;
       int valgrind_stackid;
       thread_status status;
       void * retval;
       struct thread_t *join_thread;
       struct signal* signal_handler;
};
\end{verbatim}

Cette structure regroupe les champs :
\begin{itemize}

\item id : l identifiant du thread

\item uc : le contexte d exécution d un thread

\item valgrind\_stackid : l identifiant de la pile juste après son allocation

\item status : l état d un thread. Il s agit d un type énuméré qui regroupe les états RUNNING, READY et TERMINATED.

\item retval : la valeur de retour d un thread

\item join\_thread : Afin d'améliorer les performances de notre bibliothèque, nous avons ajouté ce champ dans la structure thread\_t. Ce thread est utilisé quand un thread thread\_1 fait un thread\_join sur un thread\_2, le premier ne sera pas ajouté à la fifo \textit{waitq} mais sera stocké dans le champ join\_thread du deuxième. Ainsi, quand le deuxième thread passe la main, le premier est lancé directement à partir de ce champ et nous n'avons plus besoin de le chercher dans la fifo. 

\item signal\_handler : représente le gestionnaire de signaux associé au thread en question. Ce champ a été ajouté pour mettre en place un système de gestion de signaux qui permet d'envoyer un signal à un thread particulier. La structure \textbf{signal} sera détaillée plus tard.

\end{itemize}

\subsection{La structure d'organisation des threads}

Au départ, nous avons choisi d'utiliser la structure de données \textit{liste} implémentée par une liste doublement chainée. Cette structure est appelée fifo et elle est définie dans le fichier \textbf{fifo.c}.

Cependant structure sert uniquement à manipuler les threads puisque les datas contenus dans les éléments de la liste sont de type \textbf{thread\_t}. Nous avons donc dû mdifier la structure pour la rendre générique pour pouvoir manipuler les 
La structure élément est définie comme suit:
\begin{verbatim}
struct element {

       thread_t* data;

       element* next;

       element* prev;

};
\end{verbatim}