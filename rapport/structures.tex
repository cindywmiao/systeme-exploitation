Dans cette partie, nous allons présenter et expliquer les structures réalisées pour la construction de la bibliothèque de gestion de threads. Ensuite, nous allons nous intéresser à  l'implémentation de cette interface de threads qui permet de créer, détruire, passer la main à un thread particulier, attendre la/une terminaison, etc.


\subsection{La structure des threads}

Pour représenter un thread en mémoire, nous avons défini la structure suivante :

\begin{verbatim}
struct thread_t {

       pid_t pid;

       ucontext_t uc;

       int valgrind_stackid;

       thread_status status;

       void * retval;

};
\end{verbatim}

Cette structure regroupe les champs :
\begin{itemize}

\item id : l’identifiant du thread

\item uc : le contexte d’exécution d’un thread

\item valgrind\_stackid : l’identifiant de la pile juste après son allocation

\item status : l’état d’un thread. Il s’agit d’un type énuméré qui regroupe les états RUNNING, READY et TERMINATED.

\item retval : la valeur de retour d’un thread
\end{itemize}

\subsection{La structure d’organisation des threads}

Pour construire la bibliothèque des threads, on a choisi d'utiliser la structure de données \textit{liste} implémentée par une liste doublement chainée. Il s’agit en effet d’une liste circulaire, ce qui permet d’accélerer le passage d’un thread à un autre. Cette structure est appelée fifo et elle est définie dans le fichier fifo.c :
\begin{verbatim}
Structure fifo {

        element * head;      //un pointeur vers le premier element de la file

        element * tail;      //un pointeur vers le dernier element de la file

        unsigned int size;   //un entier qui représente la taille de la file

};
\end{verbatim}

La structure élément est définie comme suit:
\begin{verbatim}
struct element {

       thread_t* data;

       element* next;

       element* prev;

};
\end{verbatim}