#include "thread.h"
#include "fifo.h"
#include <valgrind/valgrind.h>

/**
 * global variables :
 * list of running threads
 * list of waiting threads
 * pointer on current thread
 * pid generator
 */
struct fifo * runq = NULL;
struct fifo * waitq = NULL;
struct thread_t current;
unsigned int ID = 0;


struct thread_t * thread_init(void){
  struct thread_t * thread;
  thread->id = ID++;
  thread->status = READY;
  thread->next = NULL;
  thread->prev = NULL;
  thread->priority = 20;
  thread->retval = NULL;
 

  thread->uc->uc_stack.ss_size = STACK_SIZE;
  thread->uc->uc_stack.ss_sp = malloc(thread->uc->uc_stack.ss_size);
  thread->uc->uc_stack.ss_flags = 0;
  thread->uc->uc_link = NULL;
  thread = malloc(sizeof(struct thread_t *));
  getcontext(thread->uc);

  thread->valgrind_stackid = VALGRIND_STACK_REGISTER(thread->uc->uc_stack.ss_sp,
						     thread->uc->uc_stack.ss_sp +
						     thread->uc->uc_stack.ss_size);  
  return thread;
}
/* liberer un thread
 */
void thread_free(struct thread_t *thread){

  if(thread != NULL){

    if(thread->uc->uc_stack.ss_sp != NULL)
      free(thread->uc->uc_stack.ss_sp);
    VALGRIND_STACK_DEREGISTER(th->valgrind_stackid);
    free(thread);
  }

}

struct thread_t thread_self(void){

  return current;
}


int thread_create(struct thread_t *newthread, void *(*func)(void *), void *funcarg)
{ 
  //if waitq == NULL initialiser la bibliotheque
 
  newthread = thread_init();
  if (newthread->uc->uc_stack.ss_sp == NULL)
    return -1;
  makecontext(&(newthread->uc), (void (*)(void)) func, 1, funcarg);
  fifo_addthread(waitq, newthread);
  return 0;
}


/* attendre la fin d'exécution d'un thread.
 * la valeur renvoyée par le thread est placée dans *retval.
 * si retval est NULL, la valeur de retour est ignorée.
 */
int thread_join(thread_t thread, void **retval){

  struct thread_t* t = (struct thread_t*) thread;

  if (t->status==READY)
    thread_switch();
  //attendre si le thread est dejà exécuté 
  while (thread.status==RUNNING){}
    
  if (retval != NULL)
    return (int) t->retval;

  return 0; 
}

int thread_switch() {
  struct thread_t* old = (struct thread_t*) current;

  // s'il n'y aucun thread prêt à être exécuté
  if(waitq == NULL)
    return 0;

  struct thread_t* new = (struct thread_t*) fifo_remove_head(waitq); //sélectionner le thread
  if(current!= NULL) {
    fifo_addthread(waitq,current);
    old->status = READY;
  }
  current = new;
  new->status = RUNNING;

  if(old != NULL) {
    swapcontext(&(old->uc),&(new->uc)); //restaurer le context du new et mémoriser celui du old
  }
  else
    setcontext(&(new->uc)); //restaurer le contexte 
  return 0;
}

int thread_yield(void) {
  // if waitq == NULL

  return thread_switch();
}

/* terminer le thread courant en renvoyant la valeur de retour retval.
 * cette fonction ne retourne jamais.
 *
 * L'attribut noreturn aide le compilateur à optimiser le code de
 * l'application (élimination de code mort). Attention à ne pas mettre
 * cet attribut dans votre interface tant que votre thread_exit()
 * n'est pas correctement implémenté (il ne doit jamais retourner).
 */
void thread_exit(void* retval) {
  struct thread_t* t = (struct thread_t*) current;
  thread->retval = retval;
  current_thread = NULL;  
  thread_switch();
}
