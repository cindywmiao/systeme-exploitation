#include "thread.h"
#include "fifo.h"
#include <valgrind/valgrind.h>

/**
 * global variables :
 * list of running threads
 * list of waiting threads
 * pointer on current thread
 * pid generator
 */
struct fifo * runq = NULL;
struct fifo * waitq = NULL;
struct thread_t current;
unsigned int ID = 0;


struct thread_t * thread_init(void){
  struct thread_t * thread;
  thread->id = ID++;
  thread->status = READY;
  thread->next = NULL;
  thread->prev = NULL;
  thread->priority = 20;
  thread->retval = NULL;
 

  thread->uc->uc_stack.ss_size = STACK_SIZE;
  thread->uc->uc_stack.ss_sp = malloc(thread->uc->uc_stack.ss_size);
  thread->uc->uc_stack.ss_flags = 0;
  thread->uc->uc_link = NULL;
  thread = malloc(sizeof(struct thread_t *));
  getcontext(thread->uc);

  thread->valgrind_stackid = VALGRIND_STACK_REGISTER(thread->uc->uc_stack.ss_sp,
						     thread->uc->uc_stack.ss_sp +
						     thread->uc->uc_stack.ss_size);  
  return thread;
}
/* liberer un thread
 */
void thread_free(struct thread_t *thread){

  if(thread != NULL){

    if(thread->uc->uc_stack.ss_sp != NULL)
      free(thread->uc->uc_stack.ss_sp);
    VALGRIND_STACK_DEREGISTER(th->valgrind_stackid);
    free(thread);
  }

}

struct thread_t thread_self(void){

  return current;
}


int thread_create(struct thread_t *newthread, void *(*func)(void *), void *funcarg)
{
  //initialiser la bib?
  /*
	if(getcontext((newthread->uc)) == -1)
	  {
	    printf("Erreur de new thread\n");
	    return -1;
	  }
	//	newthread->uc->uc_link = &exit_context;
  */
  
  newthread = thread_init();
  if (newthread->uc->uc_stack.ss_sp == NULL)
    return -1;
  makecontext(&(newthread->uc), (void (*)(void)) func, 1, funcarg);
  fifo_addthread(waitq, newthread);
  return 0;
}


int thread_join(thread_t thread, void **retval){
  int err = 0;
  ucontext_t uc;

  if (thread.status==READY)
    //setcontext(thread.uc);
    swapcontext(&uc, thread.uc);
    //fifo
  while (thread.status==RUNNING){}
    
  if (retval != NULL)
    return (int) thread.retval;
  return err;
}
