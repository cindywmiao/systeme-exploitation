Travail accompli

Dans cette partie, nous allons présenter et expliquer les structures réalisées pour la construction de la bibliothèque de gestion de threads. Ensuite, nous allons nous intéresser à  l'implémentation de cette interface de threads qui permet de créer, détruire, passer la main à un thread particulier, attendre la/une terminaison, etc.

Structure de données

La structure des threads :

Pour représenter un thread en mémoire, nous avons défini la structure suivante :

struct thread_t {

pid_t pid;

ucontext_t uc;

int valgrind_stackid;

thread_status status;

void * retval;

void* func;

void* funcarg;

unsigned char priority;

};

Cette structure regroupe les champs :

    id : l’identifiant du thread

    uc : le contexte d’exécution d’un thread

    valgrind_stackid : l’identifiant de la pile juste après son allocation

    status : l’état d’un thread. Il s’agit du’n type énuméré qui regroupe les états RUNNING, READY et BLOCKED.

    retval : la valeur de retour d’un thread

    func :

    funcarg :

    priority:


La structure d’organisation des threads :

Pour construire la bibliothèque des threads, on a choisi d'utiliser la structure de données liste implémentée par une liste doublement chainée. Il s’agit en effet d’une liste circulaire, ce qui permet d’accélerer le passage d’un thread à un autre. Cette structure est appelée fifo et elle est définie dans le fichier fifo.c :

Structure fifo {

element * head;   un pointeur vers le premier element de la file

element * tail;       un pointeur vers le dernier element de la file

unsigned int size;  un entier qui représente la taille de la file

};

La structure élément est définie comme suit:

struct element {

thread_t* data;

element* next;

element* prev;

};
