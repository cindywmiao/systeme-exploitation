#include "thread.h"
fifo_t * f;

thread_t thread_self(void){

  /* ucontext_t uc, previous; */

  /* getcontext(&uc); /\* initialisation de uc avec valeurs coherentes */
  /* 		    * (pour Ã©viter de tout remplit a la main ci-dessous) *\/ */

  /* uc.uc_stack.ss_size = 64*1024; */
  /* uc.uc_stack.ss_sp = malloc(uc.uc_stack.ss_size); */
  /* uc.uc_link = &previous; */


  thread_t t;
  /* t.status = 0; */
  /* int err = getcontext(t.uc); */
  /* (t.uc->uc_stack).ss_size = 64*1024; */
  /* (t.uc->uc_stack).ss_sp = malloc(t.uc->uc_stack.ss_size); */
  /* t.uc->uc_link = NULL; */
  

  return t;
}

int thread_create(thread_t *newthread, void *(*func)(void *), void *funcarg){
  
  int err = 0;
  /* *newthread = thread_self(); */
  /* getcontext(newthread->uc); */
  /* getcontext(newthread->uc); */
  /* // ucontext_t uc; */
  /* newthread->uc->uc_stack.ss_size = 64*1024; */
  /* newthread->uc->uc_stack.ss_sp = malloc(newthread->uc->uc_stack.ss_size); */
  /* newthread->uc->uc_link = NULL; */
  /* makecontext((newthread->uc),(void(*)(void)) func, 1, 0); */

  return err;

}

int thread_yield(void){
  int err = 0;
  //swapcontext(f->head,f->next);
  return err;
  
}

int thread_join(thread_t thread, void **retval){
  int err = 0;
  setcontext(thread.uc);
  return err;
}

void thread_exit(void *retval) __attribute__ ((__noreturn__)) ;
void thread_exit(void *retval){
}
